%{

  #include <string>
  #include <stdio.h>
  #include <iostream>
  #include "structs.hpp"
  #include "symboltable.hpp"
  #include <string>
  #include "ReturnValue.hpp" 
  #include "tokens.h"
  #include "lexer.h"
  #include "functiontable.hpp"
  #include "lex.yy.c"

  Stm thesyntree;

%}

//TODO: implement the rest and implement package main functionality
// -> make initial program statement consisting of a statement list 
// these statements will be executed 
// after that is done lookup the main function in the function table and execute everything


%union{
  //Literals and base classes
  char* id;

  bool boollit;
  int intlit;
  Stm stm;
  Exp exp;

  //Lists
  ExpList* explist;
  StmList* stmlist;
  IdList*  idlist;
}

%token <id> IDEN 
%token <boollit> BOOLLITERAL
%token <intlit> INTLITERAL
%token  SEMICOLON INT BOOL RETURN VAR IF FOR LPAREN RPAREN LBRACE RBRACE PLUS MIN MUL DIV PLUSASSIGN MINASSIGN 
%token  MULASSIGN DIVASSIGN AND OR NOT INC DEC GT GE LT LE EQ NE 
%token  COMMA PRINT FUNC PACKAGE IS

%left MUL DIV
%left PLUS MIN
%nonassoc EQ NE
%nonassoc GT GE LT LE
%nonassoc AND
%nonassoc OR



//Base 
%type <stm> statement
%type <exp> expression

//Variable type (returned from the lexer as integer, ignore type conflict)
%type <intlit> type

//Lists
%type <explist> expressionlist
%type <stmlist> statementlist
%type <idlist> identifierlist

//Statements
%type <stm> print_statement
%type <stm> block_statement 
%type <stm> if_statement
%type <stm> for_statement
%type <stm> declaration_statement
%type <stm> assignment_statement

//Expressions

%start program

%%

program : statementlist
        | ;

statement : block_statement
          | if_statement
          | for_statement
          | print_statement
          | declaration_statement
          | assignment_statement
          ;

identifierlist : IDEN COMMA identifierlist {std::cout << "identifierlist : IDEN COMMA identifierlist \n"; 
                                          $$ = new IdList(yyval.id, $3);}
               | IDEN {std::cout << "identifierlist : IDEN \n";
                      $$ = new IdList(yyval.id, nullptr);}
               ;

statementlist : statement statementlist {std::cout << "statementlist: statement statementlist \n"; 
                                        $$ = new StmList($1, $2);}
              | statement {std::cout << "statementlist: statement statementlist \n"; 
                                        $$ = new StmList($1, nullptr);}
              ; 

block_statement : LBRACE statementlist RBRACE{std::cout << "LBRACE statementlist RBRACE \n";
                                              $$ = new BlockStm($2); thesyntree = $$;}
                |  LBRACE RBRACE{std::cout << "LBRACE RBRACE \n";
                                              $$ = new BlockStm(nullptr); thesyntree = $$;}
                ;

if_statement : IF LPAREN expression RPAREN block_statement{std::cout << "IF LPAREN expression RPAREN block_statement \n"; 
                                                          $$ = new If_stm($3, $5); thesyntree = $$;} //Else not implemented
             ;

for_statement : FOR LPAREN expression RPAREN block_statement{std::cout << "for_statement : FOR LPAREN expression RPAREN block_statement \n"; 
                                                            $$ = new For_stm($3, $5); thesyntree = $$;}
              ;

print_statement : PRINT LPAREN expressionlist RPAREN SEMICOLON{std::cout << "print_statement : PRINT LPAREN expressionlist RPAREN \n"; 
                                                      $$ = new PrintStm($3); thesyntree = $$;}

declaration_statement : 
                        VAR identifierlist IS expressionlist SEMICOLON{std::cout << "declaration_statement : VAR identifierlist EQ expressionlist SEMICOLON \n";
                                                                      $$ = new DeclarationStm(-1, $2, $4); thesyntree = $$;}    
                      | VAR identifierlist type IS expressionlist SEMICOLON {std::cout << "declaration_statement : VAR identifierlist type EQ expressionlist SEMICOLON \n";
                                                                            $$ = new DeclarationStm($3, $2, $5); thesyntree = $$;}
                      | VAR identifierlist type SEMICOLON {std::cout << "declaration_statement : VAR identifierlist type SEMICOLON \n";
                                    $$ = new DeclarationStm($3, $2, nullptr); thesyntree = $$;}
                      ;

type : INT
     | BOOL
     ;

assignment_statement : identifierlist IS expressionlist SEMICOLON {$$ = new AssignStm($1, $3); thesyntree = $$;}
           ;


//EXPRESSIONS

expressionlist : expressionlist COMMA expression {std::cout << "expressionlist COMMA expression  \n";
                                                 $$ = new ExpList($3, $1);}
               | expression {std::cout << "expression  \n";
                            $$ = new ExpList($1, nullptr);}
               ;

expression : INTLITERAL {std::cout << "INTLITERAL" << yylval.intlit << "\n";
                        $$ = new IntlitExp(yylval.intlit);} 
           | BOOLLITERAL {std::cout << "BOOLLITERAL " << yylval.boollit << "\n";
                         $$ = new BoollitExp(yylval.boollit);}
           | IDEN {

              ReturnValue returnValue = symbolhandler.lookupSymbol(yylval.id);

              if(returnValue.intValue == nullptr){
                $$ = new BoollitExp(*returnValue.boolValue);
              }
              else{
                $$ = new IntlitExp(*returnValue.intValue);
              }
            
            }
          
           | LPAREN expression RPAREN  {std::cout << "LPAREN expression RPAREN  \n";}              
           ;

  
%%



int main(int argc, char* argv[]) {
    
    char *tokens[] = {
    "SEMICOLON",
    "ID",
    "INT", "BOOL",
    "PACKAGE", "RETURN", "VAR", "IF", "FOR",
    "LPAREN", "RPAREN", "LBRACE", "RBRACE",
    "PLUS", "MIN", "MUL", "DIV", 
    "PLUSASSIGN", "MINASSIGN", "MULASSIGN", "DIVASSIGN",
    "AND", "OR", "NOT",
    "INC", "DEC",
    "GT", "GE", "LT", "LE", "EQ", "NE",
    "INTLITERAL", "BOOLLITERAL"
    }; 


    int tokenid;

    symbolhandler.pushSymbolTable(SymbolTable());

    yyin = fopen("./gotest.txt", "r");
 
    std::cout << "\n";
    std::cout << "Parsing instructions: " << "\n\n";
    yyparse();

    std::cout << "\n\nInterpreting AST: \n";

    thesyntree->interp();  

    return 0;
}

void yyerror (char *s) {
    std::cerr << s << " " << yytext << std::endl;
}
